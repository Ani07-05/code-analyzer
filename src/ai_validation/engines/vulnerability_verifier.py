"""
Dynamic VulnerabilityVerifier - VRAM-Aware AI Security Analysis
File: src/ai_validation/engines/dynamic_vulnerability_verifier.py

Automatically adapts to GPU VRAM and offers AI API fallbacks for optimal performance.
"""

import re
import time
import logging
import asyncio
import platform
from typing import Dict, Optional, Any, List, Tuple
from pathlib import Path
from dataclasses import dataclass
from enum import Enum

try:
    import GPUtil
    import psutil
    GPU_UTILS_AVAILABLE = True
except ImportError:
    GPU_UTILS_AVAILABLE = False

from ..models.validation_models import VulnerabilityAnalysis
from ..managers.model_manager import ModelManager

# Import EntryPoint with absolute import
import sys
from pathlib import Path
try:
    from entry_detector.models import EntryPoint
except ImportError:
    # Fallback for relative imports
    sys.path.append(str(Path(__file__).parent.parent.parent))
    from entry_detector.models import EntryPoint


class VRAMTier(Enum):
    """VRAM-based performance tiers."""
    ULTRA_LOW = "ultra_low"    # <2GB - API recommended
    LOW = "low"                # 2-4GB - Basic analysis
    MEDIUM = "medium"          # 4-8GB - Standard analysis  
    HIGH = "high"              # 8-16GB - Detailed analysis
    ULTRA_HIGH = "ultra_high"  # 16GB+ - Premium analysis


@dataclass
class VRAMConfig:
    """Configuration based on VRAM tier."""
    tier: VRAMTier
    max_context_lines: int
    max_generation_tokens: int
    temperature: float
    use_cpu_offload: bool
    recommend_api: bool
    description: str


class SystemSpecDetector:
    """Detect system specifications for optimal configuration."""
    
    @staticmethod
    def get_gpu_vram() -> Tuple[float, str]:
        """Get GPU VRAM in GB and GPU name."""
        if not GPU_UTILS_AVAILABLE:
            return 0.0, "No GPU detected"
        
        try:
            gpus = GPUtil.getGPUs()
            if not gpus:
                return 0.0, "No GPU detected"
            
            # Get primary GPU
            gpu = gpus[0]
            vram_gb = gpu.memoryTotal / 1024  # Convert MB to GB
            return vram_gb, gpu.name
            
        except Exception:
            return 0.0, "GPU detection failed"
    
    @staticmethod
    def get_ram() -> float:
        """Get system RAM in GB."""
        try:
            ram_bytes = psutil.virtual_memory().total
            return ram_bytes / (1024**3)  # Convert to GB
        except Exception:
            return 8.0  # Default assumption
    
    @staticmethod
    def get_cpu_info() -> Dict[str, Any]:
        """Get CPU information."""
        return {
            "cores": psutil.cpu_count(logical=False),
            "threads": psutil.cpu_count(logical=True),
            "architecture": platform.machine(),
            "processor": platform.processor()
        }


class VRAMConfigManager:
    """Manages VRAM-based configurations."""
    
    VRAM_CONFIGS = {
        VRAMTier.ULTRA_LOW: VRAMConfig(
            tier=VRAMTier.ULTRA_LOW,
            max_context_lines=15,
            max_generation_tokens=350,
            temperature=0.2,
            use_cpu_offload=True,
            recommend_api=True,
            description="Ultra Low VRAM (<2GB) - API Recommended"
        ),
        VRAMTier.LOW: VRAMConfig(
            tier=VRAMTier.LOW,
            max_context_lines=25,
            max_generation_tokens=500,
            temperature=0.15,
            use_cpu_offload=True,
            recommend_api=False,
            description="Low VRAM (2-4GB) - Basic Analysis"
        ),
        VRAMTier.MEDIUM: VRAMConfig(
            tier=VRAMTier.MEDIUM,
            max_context_lines=40,
            max_generation_tokens=800,
            temperature=0.1,
            use_cpu_offload=False,
            recommend_api=False,
            description="Medium VRAM (4-8GB) - Standard Analysis"
        ),
        VRAMTier.HIGH: VRAMConfig(
            tier=VRAMTier.HIGH,
            max_context_lines=60,
            max_generation_tokens=1200,
            temperature=0.1,
            use_cpu_offload=False,
            recommend_api=False,
            description="High VRAM (8-16GB) - Detailed Analysis"
        ),
        VRAMTier.ULTRA_HIGH: VRAMConfig(
            tier=VRAMTier.ULTRA_HIGH,
            max_context_lines=80,
            max_generation_tokens=1500,
            temperature=0.05,
            use_cpu_offload=False,
            recommend_api=False,
            description="Ultra High VRAM (16GB+) - Premium Analysis"
        )
    }
    
    @classmethod
    def get_vram_tier(cls, vram_gb: float) -> VRAMTier:
        """Determine VRAM tier based on available memory."""
        if vram_gb < 2.0:
            return VRAMTier.ULTRA_LOW
        elif vram_gb < 4.0:
            return VRAMTier.LOW
        elif vram_gb < 8.0:
            return VRAMTier.MEDIUM
        elif vram_gb < 16.0:
            return VRAMTier.HIGH
        else:
            return VRAMTier.ULTRA_HIGH
    
    @classmethod
    def get_config(cls, vram_gb: float) -> VRAMConfig:
        """Get configuration for VRAM amount."""
        tier = cls.get_vram_tier(vram_gb)
        return cls.VRAM_CONFIGS[tier]


class APIFallbackManager:
    """Manages AI API fallbacks for low VRAM systems."""
    
    SUPPORTED_APIS = {
        "gemini": {
            "name": "Google Gemini Pro",
            "cost": "Free tier available",
            "setup": "Get API key from Google AI Studio"
        },
        "claude": {
            "name": "Anthropic Claude",
            "cost": "Pay per use",
            "setup": "Get API key from Anthropic Console"
        },
        "openai": {
            "name": "OpenAI GPT-4",
            "cost": "Pay per use", 
            "setup": "Get API key from OpenAI Platform"
        }
    }
    
    @classmethod
    def suggest_api_options(cls) -> str:
        """Generate API options suggestion."""
        suggestions = ["ðŸš€ **AI API OPTIONS FOR BETTER PERFORMANCE:**\n"]
        
        for api_id, info in cls.SUPPORTED_APIS.items():
            suggestions.append(f"**{info['name']}**")
            suggestions.append(f"  â€¢ Cost: {info['cost']}")
            suggestions.append(f"  â€¢ Setup: {info['setup']}")
            suggestions.append("")
        
        return "\n".join(suggestions)


class DynamicVulnerabilityVerifier:
    """
    Dynamic vulnerability verifier that adapts to system specifications.
    
    Features:
    - Automatic VRAM detection and optimization
    - VRAM-based configuration tiers
    - AI API fallback recommendations
    - Enhanced HTML report generation
    """
    
    def __init__(self, model_manager: ModelManager, force_api_mode: bool = False):
        self.model_manager = model_manager
        self.force_api_mode = force_api_mode
        self.logger = logging.getLogger(__name__)
        self.cached_model = None
        
        # Detect system specifications
        self.system_specs = self._detect_system_specs()
        self.config = self._get_optimal_config()
        
        # Log system configuration
        self._log_system_configuration()
        
        # Recommend API if needed
        if self.config.recommend_api and not force_api_mode:
            self._show_api_recommendation()
    
    def _detect_system_specs(self) -> Dict[str, Any]:
        """Detect comprehensive system specifications."""
        detector = SystemSpecDetector()
        
        vram_gb, gpu_name = detector.get_gpu_vram()
        ram_gb = detector.get_ram()
        cpu_info = detector.get_cpu_info()
        
        return {
            "vram_gb": vram_gb,
            "gpu_name": gpu_name,
            "ram_gb": ram_gb,
            "cpu_cores": cpu_info["cores"],
            "cpu_threads": cpu_info["threads"],
            "architecture": cpu_info["architecture"]
        }
    
    def _get_optimal_config(self) -> VRAMConfig:
        """Get optimal configuration based on system specs."""
        if self.force_api_mode:
            # Return highest quality config for API mode
            return VRAMConfigManager.VRAM_CONFIGS[VRAMTier.ULTRA_HIGH]
        
        return VRAMConfigManager.get_config(self.system_specs["vram_gb"])
    
    def _log_system_configuration(self):
        """Log detected system configuration."""
        specs = self.system_specs
        
        self.logger.info("ðŸ”§ SYSTEM CONFIGURATION DETECTED")
        self.logger.info(f"GPU: {specs['gpu_name']}")
        self.logger.info(f"VRAM: {specs['vram_gb']:.1f}GB")
        self.logger.info(f"RAM: {specs['ram_gb']:.1f}GB")
        self.logger.info(f"CPU: {specs['cpu_threads']} threads")
        self.logger.info(f"Config Tier: {self.config.tier.value.upper()}")
        self.logger.info(f"Max Tokens: {self.config.max_generation_tokens}")
        self.logger.info(f"Context Lines: {self.config.max_context_lines}")
        
        if self.config.recommend_api:
            self.logger.warning("âš ï¸  Low VRAM detected - Consider using AI APIs for better performance")
    
    def _show_api_recommendation(self):
        """Show API recommendation for low VRAM systems."""
        print("\n" + "="*60)
        print("ðŸš¨ LOW VRAM DETECTED - PERFORMANCE WARNING")
        print("="*60)
        print(f"Your GPU has only {self.system_specs['vram_gb']:.1f}GB VRAM")
        print("This may result in:")
        print("  â€¢ Limited analysis depth (only 350 tokens)")
        print("  â€¢ Slower processing")
        print("  â€¢ Potential out-of-memory errors")
        print("\n" + APIFallbackManager.suggest_api_options())
        print("To use API mode, initialize with: force_api_mode=True")
        print("="*60 + "\n")
    
    async def verify_vulnerability(self, 
                                 entry_point: EntryPoint,
                                 source_code: str,
                                 project_context: Optional[Dict[str, Any]] = None) -> VulnerabilityAnalysis:
        """Generate dynamic vulnerability analysis based on system capabilities."""
        
        vuln_type = self._infer_vulnerability_type(entry_point)
        
        self.logger.info(f"Generating {self.config.tier.value} analysis for {vuln_type}")
        
        start_time = time.time()
        
        try:
            if self.force_api_mode:
                # Use API-based analysis (placeholder - implement your API calls here)
                return await self._generate_api_analysis(entry_point, source_code, vuln_type)
            else:
                # Use local model analysis
                return await self._generate_local_analysis(entry_point, source_code, vuln_type)
                
        except Exception as e:
            self.logger.error(f"Analysis failed: {e}")
            return self._create_fallback_analysis(entry_point, str(e))
    
    async def _generate_local_analysis(self, entry_point: EntryPoint, source_code: str, vuln_type: str) -> VulnerabilityAnalysis:
        """Generate analysis using local model."""
        
        # Get model with appropriate complexity
        task_complexity = "simple" if self.config.tier in [VRAMTier.ULTRA_LOW, VRAMTier.LOW] else "complex"
        model = await self.model_manager.get_model(task_complexity=task_complexity)
        
        # Extract context based on VRAM tier
        context = self._extract_adaptive_context(entry_point, source_code)
        
        # Create tier-appropriate prompt
        prompt = self._create_adaptive_prompt(entry_point, context, vuln_type)
        
        # Generate analysis with tier-specific settings
        response = await model.generate(
            prompt=prompt,
            max_tokens=self.config.max_generation_tokens,
            temperature=self.config.temperature
        )
        
        return self._parse_analysis_response(response, entry_point, vuln_type)
    
    async def _generate_api_analysis(self, entry_point: EntryPoint, source_code: str, vuln_type: str) -> VulnerabilityAnalysis:
        """Generate analysis using API (placeholder for API implementation)."""
        
        # This is where you'd implement API calls to Gemini, Claude, etc.
        # For now, return a high-quality placeholder
        
        self.logger.info("API mode analysis (implement your preferred API)")
        
        return VulnerabilityAnalysis(
            is_genuine_vulnerability=True,
            confidence_score=0.9,
            false_positive_probability=0.1,
            code_context_analysis="High-quality API-based analysis would go here",
            data_flow_analysis="Comprehensive data flow analysis via API",
            business_impact_assessment="MEDIUM - Detailed API assessment",
            ai_reasoning="API-powered comprehensive security analysis",
            evidence_citations=["API-based analysis performed", "High confidence assessment"]
        )
    
    def _extract_adaptive_context(self, entry_point: EntryPoint, source_code: str) -> str:
        """Extract context based on VRAM tier capabilities."""
        lines = source_code.split('\n')
        
        # Adjust context size based on tier
        context_radius = self.config.max_context_lines // 3
        start_line = max(0, entry_point.line_start - context_radius - 1)
        end_line = min(len(lines), entry_point.line_end + context_radius)
        
        context_parts = []
        
        # For higher tiers, include more comprehensive context
        if self.config.tier in [VRAMTier.HIGH, VRAMTier.ULTRA_HIGH]:
            # Include function context
            function_context = self._extract_function_context(entry_point, lines)
            if function_context:
                context_parts.append("=== FUNCTION CONTEXT ===")
                context_parts.append(function_context)
                return "\n".join(context_parts)
        
        # Standard context for lower tiers
        context_parts.append("=== CODE CONTEXT ===")
        for i in range(start_line, end_line):
            if i < len(lines):
                line = lines[i]
                line_num = i + 1
                
                if entry_point.line_start <= line_num <= entry_point.line_end:
                    marker = ">>> VULNERABLE: "
                else:
                    marker = f"{line_num:4d}: "
                
                context_parts.append(f"{marker}{line}")
        
        return "\n".join(context_parts)
    
    def _extract_function_context(self, entry_point: EntryPoint, lines: List[str]) -> Optional[str]:
        """Extract function context for higher-tier analysis."""
        target_line = entry_point.line_start
        
        # Find function start
        func_start = None
        for i in range(target_line - 1, -1, -1):
            if i < len(lines):
                line = lines[i].strip()
                if line.startswith(('def ', 'async def ')):
                    func_start = i
                    break
        
        if func_start is None:
            return None
        
        # Find function end
        func_end = len(lines)
        base_indent = len(lines[func_start]) - len(lines[func_start].lstrip())
        
        for i in range(func_start + 1, len(lines)):
            line = lines[i]
            if line.strip():
                current_indent = len(line) - len(line.lstrip())
                if current_indent <= base_indent:
                    func_end = i
                    break
        
        # Build function context
        function_lines = []
        for i in range(func_start, func_end):
            if i < len(lines):
                line_num = i + 1
                line = lines[i]
                
                if entry_point.line_start <= line_num <= entry_point.line_end:
                    marker = ">>> VULNERABLE: "
                else:
                    marker = f"{line_num:4d}: "
                
                function_lines.append(f"{marker}{line}")
        
        return "\n".join(function_lines)
    
    def _create_adaptive_prompt(self, entry_point: EntryPoint, context: str, vuln_type: str) -> str:
        """Create prompt adapted to VRAM tier capabilities."""
        
        # Base security info
        security_info = self._get_security_info(vuln_type)
        
        if self.config.tier in [VRAMTier.ULTRA_LOW, VRAMTier.LOW]:
            # Concise prompt for low VRAM
            return f"""Security Analysis: {vuln_type}

{security_info}

Code Analysis:
{context}

Function: {entry_point.function_name}()
Risk: {entry_point.risk_score}/100

Analysis Required:
1. Is this a real vulnerability or false positive?
2. What's the security risk level?
3. How can an attacker exploit this?

Format:
VULNERABILITY: [TRUE/FALSE]
CONFIDENCE: [0.0-1.0]
RISK: [CRITICAL/HIGH/MEDIUM/LOW]
ANALYSIS: [Brief explanation]
EVIDENCE: [Code evidence]

Begin analysis:"""
        
        else:
            # Comprehensive prompt for higher VRAM
            return f"""Comprehensive Security Analysis: {vuln_type}

{security_info}

Target Analysis:
â€¢ Function: {entry_point.function_name}()
â€¢ File: {entry_point.file_path}
â€¢ Line: {entry_point.line_start}
â€¢ Risk Score: {entry_point.risk_score}/100

Security Profile:
{self._build_security_profile(entry_point)}

Source Code:
{context}

Comprehensive Analysis Required:

1. VULNERABILITY ASSESSMENT:
   - Is this genuine or false positive?
   - Root cause analysis
   - Attack vector analysis

2. EXPLOITABILITY:
   - Can this be realistically exploited?
   - Attack prerequisites and payload
   - Impact assessment

3. EVIDENCE & RECOMMENDATIONS:
   - Specific code evidence
   - Remediation steps
   - Security best practices

Format Response:
VULNERABILITY_STATUS: [CONFIRMED_VULNERABLE/FALSE_POSITIVE]
CONFIDENCE_LEVEL: [0.0-1.0]
SEVERITY: [CRITICAL/HIGH/MEDIUM/LOW]
TECHNICAL_ANALYSIS: [Detailed analysis]
EXPLOITATION_SCENARIO: [Attack scenario or why not exploitable]
EVIDENCE: [Specific code evidence]
RECOMMENDATIONS: [Fix recommendations]

Begin comprehensive analysis:"""
    
    def _get_security_info(self, vuln_type: str) -> str:
        """Get security framework info for vulnerability type."""
        security_map = {
            "XSS": "XSS: Unescaped user input in HTML output. Use html.escape() or template auto-escaping.",
            "SQL_INJECTION": "SQL Injection: Unsanitized input in SQL queries. Use parameterized queries.",
            "PATH_TRAVERSAL": "Path Traversal: Unvalidated file paths. Validate and sanitize all file operations.",
            "COMMAND_INJECTION": "Command Injection: User input in system commands. Avoid shell=True, validate input."
        }
        return security_map.get(vuln_type, "General security vulnerability requiring input validation.")
    
    def _build_security_profile(self, entry_point: EntryPoint) -> str:
        """Build security profile for comprehensive analysis."""
        profile_parts = []
        
        if entry_point.risk_factors:
            profile_parts.append(f"Risk Factors: {', '.join(entry_point.risk_factors)}")
        
        security_features = []
        if entry_point.input_validation_present:
            security_features.append("Input Validation")
        if entry_point.output_encoding_present:
            security_features.append("Output Encoding")
        if entry_point.csrf_protection:
            security_features.append("CSRF Protection")
        
        if security_features:
            profile_parts.append(f"Security Features: {', '.join(security_features)}")
        else:
            profile_parts.append("Security Features: None detected")
        
        return "\n".join([f"â€¢ {part}" for part in profile_parts])
    
    def _parse_analysis_response(self, response, entry_point: EntryPoint, vuln_type: str) -> VulnerabilityAnalysis:
        """Parse AI response into structured analysis."""
        
        response_text = response.text
        
        # Extract key fields
        is_vulnerable = self._extract_boolean(response_text, r'VULNERABILITY(?:_STATUS)?:\s*(TRUE|CONFIRMED_VULNERABLE|FALSE|FALSE_POSITIVE)')
        confidence = self._extract_float(response_text, r'CONFIDENCE(?:_LEVEL)?:\s*(0\.\d+|1\.0)')
        
        # Extract detailed sections
        technical_analysis = self._extract_section(response_text, r'(?:TECHNICAL_)?ANALYSIS:\s*(.+?)(?=\n[A-Z_]+:|$)')
        evidence = self._extract_section(response_text, r'EVIDENCE:\s*(.+?)(?=\n[A-Z_]+:|$)')
        
        return VulnerabilityAnalysis(
            is_genuine_vulnerability=is_vulnerable,
            confidence_score=confidence,
            false_positive_probability=1.0 - confidence,
            code_context_analysis=technical_analysis or "Security analysis completed",
            data_flow_analysis=f"Data flow analysis for {vuln_type}",
            business_impact_assessment="MEDIUM",
            ai_reasoning=f"AI analysis using {self.config.description}",
            evidence_citations=[evidence] if evidence else ["Analysis completed"]
        )
    
    def _extract_boolean(self, text: str, pattern: str) -> bool:
        """Extract boolean value from response."""
        match = re.search(pattern, text, re.IGNORECASE)
        if match:
            value = match.group(1).upper()
            return value in ["TRUE", "CONFIRMED_VULNERABLE"]
        return True  # Conservative default
    
    def _extract_float(self, text: str, pattern: str) -> float:
        """Extract float value from response."""
        match = re.search(pattern, text)
        if match:
            try:
                return float(match.group(1))
            except ValueError:
                pass
        return 0.7  # Default confidence
    
    def _extract_section(self, text: str, pattern: str) -> Optional[str]:
        """Extract text section from response."""
        match = re.search(pattern, text, re.DOTALL)
        if match:
            content = match.group(1).strip()
            return content if content else None
        return None
    
    def _infer_vulnerability_type(self, entry_point: EntryPoint) -> str:
        """Infer vulnerability type from entry point."""
        risk_factors = [f.lower() for f in entry_point.risk_factors]
        
        if any("sql" in f or "database" in f for f in risk_factors) or entry_point.database_access:
            return "SQL_INJECTION"
        elif any(f in ["html_output", "no_escaping", "user_input"] for f in risk_factors):
            return "XSS"
        elif entry_point.file_system_access:
            return "PATH_TRAVERSAL"
        elif entry_point.system_command_execution:
            return "COMMAND_INJECTION"
        else:
            return "SECURITY_VULNERABILITY"
    
    def _create_fallback_analysis(self, entry_point: EntryPoint, error_message: str) -> VulnerabilityAnalysis:
        """Create fallback analysis when AI fails."""
        return VulnerabilityAnalysis(
            is_genuine_vulnerability=True,
            confidence_score=0.3,
            false_positive_probability=0.7,
            code_context_analysis=f"Analysis failed: {error_message}. Conservative assessment applied.",
            data_flow_analysis="Unable to complete data flow analysis due to system limitations",
            business_impact_assessment="MEDIUM",
            ai_reasoning=f"Fallback analysis due to: {error_message}",
            evidence_citations=[
                f"System limitation: {error_message}",
                "Conservative security assessment applied",
                "Manual review recommended"
            ]
        )
    
    def get_system_info(self) -> Dict[str, Any]:
        """Get comprehensive system information."""
        return {
            "specs": self.system_specs,
            "config": {
                "tier": self.config.tier.value,
                "description": self.config.description,
                "max_tokens": self.config.max_generation_tokens,
                "max_context_lines": self.config.max_context_lines,
                "recommend_api": self.config.recommend_api
            },
            "recommendations": {
                "use_api": self.config.recommend_api,
                "cpu_offload": self.config.use_cpu_offload,
                "performance_tier": self.config.tier.value
            }
        }


# Main alias for backward compatibility
VulnerabilityVerifier = DynamicVulnerabilityVerifier