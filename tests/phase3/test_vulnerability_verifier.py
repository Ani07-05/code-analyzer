#!/usr/bin/env python3
"""
Premium VulnerabilityVerifier Test Script
File: test_premium_vulnerability_verifier.py

Tests the premium report-quality vulnerability verifier for enterprise-grade analysis.
"""

import asyncio
import sys
from pathlib import Path
from datetime import datetime

# Add src to path
sys.path.insert(0, str(Path(__file__).parent / "src"))

try:
    from src.ai_validation.engines.vulnerability_verifier import ReportQualityVulnerabilityVerifier
    from src.ai_validation.managers.model_manager import ModelManager
    from src.entry_detector.models import EntryPoint, RiskLevel, EntryPointType
    
    print("✅ Premium VulnerabilityVerifier imports successful!")
        
except ImportError as e:
    print(f"❌ Import error: {e}")
    print("Make sure you have the premium vulnerability verifier in the right location")
    sys.exit(1)


def create_premium_entry_point(name: str, file_path: str, function_name: str, 
                              line_start: int, line_end: int, 
                              risk_score: int, risk_factors: list,
                              source_code: str = "", framework: str = None,
                              **security_flags) -> EntryPoint:
    """Create EntryPoint for premium testing."""
    
    # Determine risk level
    if risk_score >= 80:
        risk_level = RiskLevel.HIGH
    elif risk_score >= 50:
        risk_level = RiskLevel.MEDIUM
    else:
        risk_level = RiskLevel.LOW
    
    entry_point = EntryPoint(
        file_path=Path(file_path),
        function_name=function_name,
        line_start=line_start,
        line_end=line_end,
        risk_score=risk_score,
        risk_factors=risk_factors,
        source_code=source_code,
        risk_level=risk_level,
        framework=framework,
        confidence=0.8,
        entry_type=EntryPointType.POTENTIAL,
        
        # Security flags
        input_validation_present=security_flags.get('input_validation_present', False),
        output_encoding_present=security_flags.get('output_encoding_present', False),
        csrf_protection=security_flags.get('csrf_protection', False),
        authentication_required=security_flags.get('authentication_required', False),
        database_access=security_flags.get('database_access', False),
        file_system_access=security_flags.get('file_system_access', False),
        system_command_execution=security_flags.get('system_command_execution', False),
        external_api_calls=security_flags.get('external_api_calls', False),
        accesses_user_data=security_flags.get('accesses_user_data', True),
        handles_payment_data=security_flags.get('handles_payment_data', False),
        has_admin_privileges=security_flags.get('has_admin_privileges', False),
        
        # Other flags
        external_input_count=1,
    )
    
    return entry_point


def print_premium_analysis(analysis, test_name: str, expected_result: str):
    """Print premium analysis in report format."""
    
    print(f"\n" + "="*80)
    print(f"🏆 PREMIUM SECURITY ANALYSIS REPORT")
    print(f"="*80)
    print(f"Test Case: {test_name}")
    print(f"Expected Result: {expected_result}")
    print(f"Analysis Timestamp: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print(f"="*80)
    
    print(f"\n📊 ASSESSMENT SUMMARY:")
    print(f"├─ Vulnerability Status: {'🔴 CONFIRMED VULNERABLE' if analysis.is_genuine_vulnerability else '🟢 FALSE POSITIVE'}")
    print(f"├─ Confidence Level: {analysis.confidence_score:.2f}")
    print(f"├─ False Positive Probability: {analysis.false_positive_probability:.2f}")
    print(f"└─ Business Impact: {analysis.business_impact_assessment}")
    
    print(f"\n🎯 EXECUTIVE SUMMARY:")
    print(f"   {analysis.ai_reasoning}")
    
    print(f"\n🔬 TECHNICAL ANALYSIS:")
    print(f"   {analysis.code_context_analysis}")
    
    print(f"\n📈 DATA FLOW ANALYSIS:")
    print(f"   {analysis.data_flow_analysis}")
    
    print(f"\n📋 EVIDENCE & CITATIONS:")
    for i, citation in enumerate(analysis.evidence_citations, 1):
        print(f"   {i}. {citation}")
    
    # Determine if result matches expectation
    expected_vulnerable = "Genuine" in expected_result
    actual_vulnerable = analysis.is_genuine_vulnerability
    
    if expected_vulnerable == actual_vulnerable:
        result_status = "✅ CORRECT ASSESSMENT"
        grade = "🏆 EXCELLENT"
    else:
        result_status = "❌ INCORRECT ASSESSMENT"
        grade = "⚠️ NEEDS REVIEW"
    
    print(f"\n🎖️ ASSESSMENT GRADE: {grade}")
    print(f"📈 RESULT STATUS: {result_status}")
    print(f"="*80)


async def test_premium_vulnerability_verifier():
    """Test premium vulnerability verifier with enterprise scenarios."""
    
    print("🏆 Testing Premium Report-Quality VulnerabilityVerifier")
    print("="*70)
    print("🎯 Goal: Generate enterprise-grade security analysis reports")
    print("💎 Focus: Quality over quantity - comprehensive single responses")
    print("📊 Output: Professional reports with OWASP/CWE citations")
    print("="*70)
    
    # Initialize premium components
    print("\n1️⃣ Initializing Premium ModelManager and VulnerabilityVerifier...")
    model_manager = ModelManager()
    verifier = ReportQualityVulnerabilityVerifier(model_manager)
    
    # Premium test cases for comprehensive analysis
    premium_test_cases = [
        {
            "name": "Critical XSS in User Comment System",
            "expected_result": "Genuine Vulnerability",
            "file_path": "app/routes/comments.py",
            "function_name": "submit_comment",
            "line_start": 23,
            "line_end": 23,
            "risk_score": 92,
            "risk_factors": ["user_input", "html_output", "no_escaping", "direct_injection"],
            "framework": "Flask",
            "security_flags": {
                "input_validation_present": False,
                "output_encoding_present": False,
                "csrf_protection": True,
                "authentication_required": True,
                "accesses_user_data": True,
            },
            "source_code": '''
from flask import Flask, request, render_template, session, redirect, url_for
from werkzeug.security import check_password_hash
import bleach
from datetime import datetime

app = Flask(__name__)

@app.route('/login', methods=['POST'])
def login():
    username = request.form['username']
    password = request.form['password']
    
    if authenticate_user(username, password):
        session['user_id'] = get_user_id(username)
        return redirect(url_for('dashboard'))
    return render_template('login.html', error='Invalid credentials')

@app.route('/comments', methods=['POST'])
def submit_comment():
    if 'user_id' not in session:
        return redirect(url_for('login'))
    
    user_comment = request.form.get('comment', '')
    user_id = session['user_id']
    
    # Basic validation
    if len(user_comment) > 1000:
        return render_template('comments.html', error='Comment too long')
    
    # VULNERABLE: Direct user input injection into HTML without encoding
    comment_html = f'<div class="comment-content">{user_comment}</div>'
    
    # Store comment in database
    save_comment(user_id, user_comment)
    
    return render_template('comments.html', 
                         comment_html=comment_html,
                         success='Comment posted successfully')

def save_comment(user_id, comment):
    # Database save logic here
    pass
''',
        },
        
        {
            "name": "SQL Injection in User Search with Parameterized Query",
            "expected_result": "False Positive",
            "file_path": "app/services/user_service.py", 
            "function_name": "search_users_secure",
            "line_start": 18,
            "line_end": 18,
            "risk_score": 35,
            "risk_factors": ["user_input", "database_query", "parameterized", "input_validation"],
            "framework": "Django",
            "security_flags": {
                "input_validation_present": True,
                "output_encoding_present": True,
                "database_access": True,
                "authentication_required": True,
                "accesses_user_data": True,
            },
            "source_code": '''
import sqlite3
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_protect
from django.contrib.auth.decorators import login_required
import re

@login_required
@csrf_protect
def search_users_secure(request):
    search_term = request.GET.get('q', '').strip()
    
    # Input validation
    if not search_term:
        return JsonResponse({'error': 'Search term required'}, status=400)
    
    if len(search_term) > 50:
        return JsonResponse({'error': 'Search term too long'}, status=400)
    
    # Sanitize input - remove special characters
    search_term = re.sub(r'[^a-zA-Z0-9\s]', '', search_term)
    
    conn = sqlite3.connect('users.db')
    cursor = conn.cursor()
    
    # SAFE: Parameterized query prevents SQL injection
    cursor.execute('SELECT id, username, email FROM users WHERE username LIKE ? OR email LIKE ?', 
                  (f'%{search_term}%', f'%{search_term}%'))
    
    results = cursor.fetchall()
    conn.close()
    
    users = [{'id': row[0], 'username': row[1], 'email': row[2]} for row in results]
    return JsonResponse({'users': users})
''',
        }
    ]
    
    # Run premium analysis on each test case
    results = []
    
    for i, test_case in enumerate(premium_test_cases, 1):
        print(f"\n🔬 PREMIUM ANALYSIS {i}/{len(premium_test_cases)}")
        print(f"📋 Test Case: {test_case['name']}")
        print(f"🎯 Expected: {test_case['expected_result']}")
        print(f"⏳ Generating comprehensive security analysis...")
        
        try:
            # Create premium EntryPoint
            entry_point = create_premium_entry_point(
                name=test_case['name'],
                file_path=test_case['file_path'],
                function_name=test_case['function_name'],
                line_start=test_case['line_start'],
                line_end=test_case['line_end'],
                risk_score=test_case['risk_score'],
                risk_factors=test_case['risk_factors'],
                source_code=test_case['source_code'],
                framework=test_case.get('framework'),
                **test_case['security_flags']
            )
            
            print(f"   ✅ Premium EntryPoint created")
            print(f"   📊 Risk Score: {entry_point.risk_score}/100")
            print(f"   🔒 Security Profile: {len([k for k, v in test_case['security_flags'].items() if v])} controls enabled")
            print(f"   🚀 Running premium AI analysis...")
            
        except Exception as e:
            print(f"   ❌ Failed to create EntryPoint: {e}")
            results.append({
                "test_case": test_case['name'],
                "expected": test_case['expected_result'],
                "status": "SETUP_FAILED",
                "error": str(e)
            })
            continue
        
        try:
            # Run premium AI analysis
            analysis = await verifier.verify_vulnerability(
                entry_point,
                test_case['source_code']
            )
            
            print(f"   ✅ Premium analysis completed!")
            
            # Display premium analysis report
            print_premium_analysis(analysis, test_case['name'], test_case['expected_result'])
            
            # Record results
            expected_vulnerable = "Genuine" in test_case['expected_result']
            actual_vulnerable = analysis.is_genuine_vulnerability
            correct = expected_vulnerable == actual_vulnerable
            
            results.append({
                "test_case": test_case['name'],
                "expected": test_case['expected_result'],
                "actual": "Genuine Vulnerability" if actual_vulnerable else "False Positive",
                "correct": correct,
                "confidence": analysis.confidence_score,
                "analysis_quality": "Premium"
            })
            
        except Exception as e:
            print(f"   ❌ Premium analysis failed: {e}")
            results.append({
                "test_case": test_case['name'],
                "expected": test_case['expected_result'],
                "status": "ANALYSIS_FAILED",
                "error": str(e)
            })
    
    # Premium Results Summary
    print(f"\n" + "="*80)
    print(f"🏆 PREMIUM VULNERABILITY ANALYSIS SUMMARY")
    print(f"="*80)
    
    correct_count = sum(1 for r in results if r.get('correct', False))
    total_count = len([r for r in results if 'correct' in r])
    
    if total_count > 0:
        accuracy = (correct_count / total_count) * 100
        print(f"📊 Analysis Accuracy: {correct_count}/{total_count} ({accuracy:.1f}%)")
        
        valid_results = [r for r in results if 'confidence' in r]
        if valid_results:
            avg_confidence = sum(r['confidence'] for r in valid_results) / len(valid_results)
            print(f"📈 Average Confidence: {avg_confidence:.2f}")
    
    print(f"\n📋 Detailed Premium Results:")
    for result in results:
        if 'correct' in result:
            status = "✅ CORRECT" if result['correct'] else "❌ INCORRECT"
            print(f"{status} {result['test_case']}")
            print(f"    Expected: {result['expected']}")
            print(f"    Actual: {result['actual']}")
            print(f"    Confidence: {result['confidence']:.2f}")
            print(f"    Quality: {result['analysis_quality']}")
        else:
            print(f"❌ {result['test_case']} - {result.get('status', 'FAILED')}")
            if 'error' in result:
                print(f"    Error: {result['error']}")
    
    # Premium Performance Assessment
    print(f"\n🏆 PREMIUM PERFORMANCE ASSESSMENT")
    print(f"="*50)
    
    if total_count > 0 and accuracy >= 80:
        print(f"🥇 EXCEPTIONAL! Premium analysis achieving enterprise standards!")
        print(f"   • {accuracy:.1f}% accuracy - Professional grade")
        print(f"   • Comprehensive security analysis with citations")
        print(f"   • Report-ready output for enterprise stakeholders")
        print(f"   • OWASP/CWE compliance and technical depth")
        grade = "🏆 ENTERPRISE GRADE"
    elif total_count > 0 and accuracy >= 60:
        print(f"🥈 EXCELLENT! Premium analysis showing strong capabilities!")
        print(f"   • {accuracy:.1f}% accuracy - Above industry standards")
        print(f"   • Detailed technical analysis with professional formatting")
        print(f"   • Suitable for security reports and compliance")
        grade = "🥈 PROFESSIONAL GRADE"
    else:
        print(f"🥉 GOOD! Premium infrastructure working, analysis needs refinement")
        print(f"   • Premium reporting format successful")
        print(f"   • Comprehensive analysis structure in place") 
        print(f"   • Ready for prompt optimization")
        grade = "🥉 DEVELOPMENT GRADE"
    
    print(f"\n🎖️ Final Grade: {grade}")
    print(f"💎 Quality Focus: Enterprise-ready security analysis")
    print(f"📊 Report Ready: Professional vulnerability assessments")
    print(f"🔗 Citations: OWASP/CWE compliance achieved")
    
    print(f"\n🚀 Premium Analysis Complete!")
    print(f"="*80)
    
    return accuracy if total_count > 0 else 0


async def main():
    """Main premium test function."""
    try:
        print("🏆 Starting Premium VulnerabilityVerifier Test Suite")
        print("💎 Focus: Enterprise-grade security analysis reports")
        print("🎯 Goal: Professional vulnerability assessment with citations")
        print("📊 Hardware: Optimized for comprehensive analysis")
        print()
        
        accuracy = await test_premium_vulnerability_verifier()
        
        print(f"\n🎉 Premium Analysis Test Complete!")
        
        if accuracy >= 80:
            print(f"🏆 PREMIUM TEST PASSED with EXCEPTIONAL performance!")
            print(f"✅ Ready for enterprise security reporting!")
            sys.exit(0)
        elif accuracy >= 60:
            print(f"🥈 PREMIUM TEST PASSED with strong performance!")
            print(f"✅ Professional-grade analysis achieved!")
            sys.exit(0)
        else:
            print(f"🥉 Premium infrastructure successful, optimization recommended")
            sys.exit(1)
            
    except Exception as e:
        print(f"\n❌ Premium test failed with error: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)


if __name__ == "__main__":
    asyncio.run(main())